import { browserLogs, getText, isBuild, readFileContent } from '~utils';

test('does not have failed requests', async () => {
	browserLogs.forEach((msg) => {
		expect(msg).not.toMatch('404');
	});
});

test('Dummy.svelte', async () => {
	expect(await getText('#component button')).toBe('dummy clicks: 0');
});

test('Dummy.svelte?raw', async () => {
	const result = await getText('#raw');
	expect(result).toMatchInlineSnapshot(`
		"<script lang=\\"ts\\">
			export let name:string;
			let clicks = 0;
		</script>
		<button on:click={()=>{clicks++}}>{name} clicks: {clicks}</button>
		<style lang=\\"scss\\">
			$blue: blue;
			button {
				color: darken($blue, 20);
			}
		</style>
		"
	`);
});

test('Dummy.svelte?raw&svelte&type=preprocessed', async () => {
	const result = await getText('#preprocessed');
	expect(result).toMatchInlineSnapshot(`
		"<script lang=\\"ts\\">export let name;
		let clicks = 0;
		</script>
		<button on:click={()=>{clicks++}}>{name} clicks: {clicks}</button>
		<style lang=\\"scss\\">button {
		  color: #000099;
		}</style>
		"
	`);
});

test('Dummy.svelte?raw&svelte&type=script&compileOptions={"customElement":true,"dev":false}', async () => {
	const result = await getText('#wcScript');
	expect(result).toMatchInlineSnapshot(`
		"/* src/Dummy.svelte generated by Svelte v3.53.1 */
		import {
			SvelteElement as SvelteElement$,
			append as append$,
			attribute_to_object as attribute_to_object$,
			detach as detach$,
			element as element$,
			flush as flush$,
			init as init$,
			insert as insert$,
			listen as listen$,
			noop as noop$,
			safe_not_equal as safe_not_equal$,
			set_data as set_data$,
			text as text$
		} from \\"svelte/internal\\";

		function create_fragment(ctx) {
			let button$;
			let t0$;
			let t1$;
			let t2$;
			let mounted;
			let dispose;

			return {
				c() {
					button$ = element$(\\"button\\");
					t0$ = text$(/*name*/ ctx[0]);
					t1$ = text$(\\" clicks: \\");
					t2$ = text$(/*clicks*/ ctx[1]);
					this.c = noop$;
				},
				m(target, anchor) {
					insert$(target, button$, anchor);
					append$(button$, t0$);
					append$(button$, t1$);
					append$(button$, t2$);

					if (!mounted) {
						dispose = listen$(button$, \\"click\\", /*click_handler$*/ ctx[2]);
						mounted = true;
					}
				},
				p(ctx, [dirty]) {
					if (dirty & /*name*/ 1) set_data$(t0$, /*name*/ ctx[0]);
					if (dirty & /*clicks*/ 2) set_data$(t2$, /*clicks*/ ctx[1]);
				},
				i: noop$,
				o: noop$,
				d(detaching) {
					if (detaching) detach$(button$);
					mounted = false;
					dispose();
				}
			};
		}

		function instance$($$self, $$props, $$invalidate) {
			let { name } = $$props;
			let clicks = 0;

			const click_handler$ = () => {
				$$invalidate(1, clicks++, clicks);
			};

			$$self.$$set = $$props => {
				if ('name' in $$props) $$invalidate(0, name = $$props.name);
			};

			return [name, clicks, click_handler$];
		}

		class Dummy$ extends SvelteElement$ {
			constructor(options) {
				super();
				this.shadowRoot.innerHTML = \`<style>button{color:#000099}</style>\`;

				init$(
					this,
					{
						target: this.shadowRoot,
						props: attribute_to_object$(this.attributes),
						customElement: true
					},
					instance$,
					create_fragment,
					safe_not_equal$,
					{ name: 0 },
					null
				);

				if (options) {
					if (options.target) {
						insert$(options.target, this, options.anchor);
					}

					if (options.props) {
						this.$set(options.props);
						flush$();
					}
				}
			}

			static get observedAttributes() {
				return [\\"name\\"];
			}

			get name() {
				return this.$$.ctx[0];
			}

			set name(name) {
				this.$$set({ name });
				flush$();
			}
		}

		export default Dummy$;"
	`);
});

test('Dummy.svelte?raw&svelte&type=style', async () => {
	const result = await getText('#style');
	expect(result).toMatchInlineSnapshot('"button.svelte-d8vj6a{color:#000099}"');
});

if (isBuild) {
	// needs to be different because dev raw script expected result is different from build raw script
	test(`build: Dummy.svelte?raw&svelte&type=script`, async () => {
		const result = await getText('#script');
		expect(result).toMatchInlineSnapshot(`
			"/* src/Dummy.svelte generated by Svelte v3.53.1 */
			import {
				SvelteComponent as SvelteComponent$,
				append as append$,
				attr as attr$,
				detach as detach$,
				element as element$,
				init as init$,
				insert as insert$,
				listen as listen$,
				noop as noop$,
				safe_not_equal as safe_not_equal$,
				set_data as set_data$,
				text as text$
			} from \\"svelte/internal\\";

			function create_fragment(ctx) {
				let button$;
				let t0$;
				let t1$;
				let t2$;
				let mounted;
				let dispose;

				return {
					c() {
						button$ = element$(\\"button\\");
						t0$ = text$(/*name*/ ctx[0]);
						t1$ = text$(\\" clicks: \\");
						t2$ = text$(/*clicks*/ ctx[1]);
						attr$(button$, \\"class\\", \\"svelte-d8vj6a\\");
					},
					m(target, anchor) {
						insert$(target, button$, anchor);
						append$(button$, t0$);
						append$(button$, t1$);
						append$(button$, t2$);

						if (!mounted) {
							dispose = listen$(button$, \\"click\\", /*click_handler$*/ ctx[2]);
							mounted = true;
						}
					},
					p(ctx, [dirty]) {
						if (dirty & /*name*/ 1) set_data$(t0$, /*name*/ ctx[0]);
						if (dirty & /*clicks*/ 2) set_data$(t2$, /*clicks*/ ctx[1]);
					},
					i: noop$,
					o: noop$,
					d(detaching) {
						if (detaching) detach$(button$);
						mounted = false;
						dispose();
					}
				};
			}

			function instance$($$self, $$props, $$invalidate) {
				let { name } = $$props;
				let clicks = 0;

				const click_handler$ = () => {
					$$invalidate(1, clicks++, clicks);
				};

				$$self.$$set = $$props => {
					if ('name' in $$props) $$invalidate(0, name = $$props.name);
				};

				return [name, clicks, click_handler$];
			}

			class Dummy$ extends SvelteComponent$ {
				constructor(options) {
					super();
					init$(this, options, instance$, create_fragment, safe_not_equal$, { name: 0 });
				}
			}

			export default Dummy$;"
		`);
	});
} else {
	test(`dev: Dummy.svelte?raw&svelte&type=script`, async () => {
		const result = await getText('#script');
		expect(result).toMatchInlineSnapshot(`
			"/* src/Dummy.svelte generated by Svelte v3.53.1 */
			import {
				SvelteComponentDev as SvelteComponentDev$,
				add_location as add_location$,
				append_dev as append_dev$,
				attr_dev as attr_dev$,
				detach_dev as detach_dev$,
				dispatch_dev as dispatch_dev$,
				element as element$,
				globals as globals$,
				init as init$,
				insert_dev as insert_dev$,
				listen_dev as listen_dev$,
				noop as noop$,
				safe_not_equal as safe_not_equal$,
				set_data_dev as set_data_dev$,
				text as text$,
				validate_slots as validate_slots$
			} from \\"svelte/internal\\";

			const { Error: Error$, Object: Object$, console: console$ } = globals$;
			const file$ = \\"src/Dummy.svelte\\";

			function create_fragment(ctx) {
				let button$;
				let t0$;
				let t1$;
				let t2$;
				let mounted;
				let dispose;

				const block$ = {
					c: function create() {
						button$ = element$(\\"button\\");
						t0$ = text$(/*name*/ ctx[0]);
						t1$ = text$(\\" clicks: \\");
						t2$ = text$(/*clicks*/ ctx[1]);
						attr_dev$(button$, \\"class\\", \\"svelte-d8vj6a\\");
						add_location$(button$, file$, 3, 0, 61);
					},
					l: function claim(nodes) {
						throw new Error$(\\"options.hydrate only works if the component was compiled with the \`hydratable: true\` option\\");
					},
					m: function mount(target, anchor) {
						insert_dev$(target, button$, anchor);
						append_dev$(button$, t0$);
						append_dev$(button$, t1$);
						append_dev$(button$, t2$);

						if (!mounted) {
							dispose = listen_dev$(button$, \\"click\\", /*click_handler$*/ ctx[2], false, false, false);
							mounted = true;
						}
					},
					p: function update(ctx, [dirty]) {
						if (dirty & /*name*/ 1) set_data_dev$(t0$, /*name*/ ctx[0]);
						if (dirty & /*clicks*/ 2) set_data_dev$(t2$, /*clicks*/ ctx[1]);
					},
					i: noop$,
					o: noop$,
					d: function destroy(detaching) {
						if (detaching) detach_dev$(button$);
						mounted = false;
						dispose();
					}
				};

				dispatch_dev$(\\"SvelteRegisterBlock\\", {
					block: block$,
					id: create_fragment.name,
					type: \\"component\\",
					source: \\"\\",
					ctx
				});

				return block$;
			}

			function instance$($$self, $$props, $$invalidate) {
				let { $$slots: slots = {}, $$scope } = $$props;
				validate_slots$('Dummy', slots, []);
				let { name } = $$props;
				let clicks = 0;

				$$self.$$.on_mount.push(function () {
					if (name === undefined && !('name' in $$props || $$self.$$.bound[$$self.$$.props['name']])) {
						console$.warn(\\"<Dummy> was created without expected prop 'name'\\");
					}
				});

				const writable_props = ['name'];

				Object$.keys($$props).forEach(key => {
					if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console$.warn(\`<Dummy> was created with unknown prop '\${key}'\`);
				});

				const click_handler$ = () => {
					$$invalidate(1, clicks++, clicks);
				};

				$$self.$$set = $$props => {
					if ('name' in $$props) $$invalidate(0, name = $$props.name);
				};

				$$self.$capture_state = () => ({ name, clicks });

				$$self.$inject_state = $$props => {
					if ('name' in $$props) $$invalidate(0, name = $$props.name);
					if ('clicks' in $$props) $$invalidate(1, clicks = $$props.clicks);
				};

				if ($$props && \\"$$inject\\" in $$props) {
					$$self.$inject_state($$props.$$inject);
				}

				return [name, clicks, click_handler$];
			}

			class Dummy$ extends SvelteComponentDev$ {
				constructor(options) {
					super(options);
					init$(this, options, instance$, create_fragment, safe_not_equal$, { name: 0 });

					dispatch_dev$(\\"SvelteRegisterComponent\\", {
						component: this,
						tagName: \\"Dummy$\\",
						options,
						id: create_fragment.name
					});
				}

				get name() {
					throw new Error$(\\"<Dummy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\\");
				}

				set name(value) {
					throw new Error$(\\"<Dummy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\\");
				}
			}

			export default Dummy$;"
		`);
	});
}
